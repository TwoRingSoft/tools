#! /usr/bin/env ruby

require 'octokit'
require 'json'
require 'optparse'
require_relative '../lib/echoexec'
require_relative '../lib/git_helpers'

# failure modes
FURTHER_REQUESTS_REQUIRE_TOKEN = 65
MISSING_REQUIRED_CREDENTIALS = 66

options = {}
parser = OptionParser.new do |opts|
  opts.banner = <<~BANNER

    Usage: sync-git [options] <directory>

           For each of your GitHub forks, clone your forked version, then go in and add a remote
           to the upstream version, and set up local tracking branches for both remotes' default
           branches. Then fast-forward them both, fetch all tags etc.

           <directory> is the path containing the directories holding your forks, and/or
           to where those you don't yet have should be cloned.

           Examples:

           sync-git -u/--username <user> -p/--password <pass> [-o/--one-time-pw <otp>] .
           sync-git -u/--username <user> -t/--token <token> .
           sync-git -u/--username <user> -t/--token -n/--repo-name that-one-repo-I-forked <token> .

           If you already have a Personal Access Token, provide it in the second form.
           Otherwise, use the first form, which will register a new token for you named
           “sync-git”. Then use that to invoke the program again. This is because
           requests using basic authentication (user/pass) are too rate limited.

           Options:

  BANNER

  opts.on('-uUSERNAME', '--username=USERNAME', 'GitHub username. Required for all invocations.') do |user| options[:username] = user end
  opts.on('-tTOKEN', '--token=TOKEN', 'GitHub personal access token. The primary way to use this program.') do |t| options[:token] = t end
  opts.on('-pPASSWORD', '--password=PASSWORD', 'GitHub password.') do |pass| options[:password] = pass end
  opts.on('-oOTP', '--one-time-pw=OTP', 'GitHub 2FA token, if you have it enabled.') do |otp| options[:otp] = otp end
  opts.on('-rREPO', '--repo-name=REPO', 'The name of a particular repository to sync.') do |repo| options[:repo] = repo end
  opts.on('-v', '--verbose', 'Enable verbose logging.') do options[:verbose] = true end
end
parser.parse!
root_dir_path = ARGV[0]

# authenticate the github client, producing a token for callers to use if they try with user/pass, as that is rate limited
github = nil
if nil != options[:token] then
  github = Octokit::Client.new(:access_token => options[:token])
  puts 'Running with provided token...'
elsif nil != options[:username] && nil != options[:password]
  github = Octokit::Client.new \
    :login    => options[:username],
    :password => options[:password]

  headers = Hash.new
  if nil != options[:otp] then
    headers['X-GitHub-OTP'] = options[:otp]
  end

  token = github.create_authorization \
    :scopes => ["user"],
    :note => "sync-git",
    :headers => headers

  puts "Created new token, use it to call sync-git again:"
  puts
  puts "\tsync-git -u #{user} -t #{token.token}"
  puts
  exit FURTHER_REQUESTS_REQUIRE_TOKEN
else
  puts "Must provide either a username/token or username/password/otp combination to authenticate."
  puts parser
  exit MISSING_REQUIRED_CREDENTIALS
end

github.auto_paginate = true

repos = github.repos

# sync owned repos
owned_repos = repos.select {|x| !x.fork}
if options[:repo] != nil then
  owned_repos.select! {|x| x.name == options[:repo]}
end
owned_repos.each do |owned_repo|
  puts '---'
  owned_repo_info = github.repo(owned_repo.id)
  sync_repo(owned_repo_info, root_dir_path)
end

# get the list of forks to sync
forks = repos.select {|x| x.fork}
if options[:repo] != nil then
  forks.select! {|x| x.name == options[:repo]}
end

# sync the forks
forks.each do |forked_repo|
  puts '---'

  forked_repo_info = github.repo(forked_repo.id)
  sync_fork(forked_repo_info, root_dir_path)
end
