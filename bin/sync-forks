#! /usr/bin/env ruby

require 'github_api'
require 'json'
require 'optparse'
require_relative '../lib/echoexec'

# failure modes
FURTHER_REQUESTS_REQUIRE_TOKEN = 65
MISSING_REQUIRED_CREDENTIALS = 66

options = {}
parser = OptionParser.new do |opts|
  opts.banner = <<~BANNER

    Usage: sync-forks [options] <directory>

           For each of your GitHub forks, clone your forked version, then go in and add a remote
           to the upstream version, and set up local tracking branches for both remotes' default
           branches. Then fast-forward them both, fetch all tags etc.

           <directory> is the path containing the directories holding your forks, and/or
           to where those you don't yet have should be cloned.

           Examples:

           sync-forks -u/--username <user> -p/--password <pass> [-o/--one-time-pw <otp>] .
           sync-forks -u/--username <user> -t/--token <token> .
           sync-forks -u/--username <user> -t/--token -n/--repo-name that-one-repo-I-forked <token> .

           If you already have a Personal Access Token, provide it in the second form.
           Otherwise, use the first form, which will register a new token for you named
           “sync-forks”. Then use that to invoke the program again. This is because
           requests using basic authentication (user/pass) are too rate limited.

           Options:

  BANNER

  opts.on('-uUSERNAME', '--username=USERNAME', 'GitHub username. Required for all invocations.') do |user| options[:username] = user end
  opts.on('-tTOKEN', '--token=TOKEN', 'GitHub personal access token. The primary way to use this program.') do |t| options[:token] = t end
  opts.on('-pPASSWORD', '--password=PASSWORD', 'GitHub password.') do |pass| options[:password] = pass end
  opts.on('-oOTP', '--one-time-pw=OTP', 'GitHub 2FA token, if you have it enabled.') do |otp| options[:otp] = otp end
  opts.on('-rREPO', '--repo-name=REPO', 'The name of a particular repository to sync.') do |repo| options[:repo] = repo end
end
parser.parse!
root_dir_path = ARGV[0]

# authenticate the github client, producing a token for callers to use if they try with user/pass, as that is rate limited
github = nil
if nil != options[:token] && nil != options[:username] then
  github = Github.new oauth_token: options[:token]
  puts 'Running with provided token...'
elsif nil != options[:username] && nil != options[:password]
  github = Github.new do |config|
     config.basic_auth = "#{options[:username]}:#{options[:password]}"
     if nil != options[:otp] then
       config.connection_options = {headers: {"X-GitHub-OTP" => options[:otp]}}
     end
  end
  token = github.auth.create scopes: ['repo'], note: 'sync-forks3'
  puts "Created new token, use it to call sync-forks again:"
  puts
  puts "\tsync-forks -u #{user} -t #{token.token}"
  puts
  exit FURTHER_REQUESTS_REQUIRE_TOKEN
else
  puts "Must provide either a username/token or username/password/otp combination to authenticate."
  puts parser
  exit MISSING_REQUIRED_CREDENTIALS
end

# get the list of forks to sync
repos = github.repos.list user: options[:username], auto_pagination: true
forks = repos.select {|x| x.fork}
if options[:repo] != nil then
  forks.select! {|x| x.name == options[:repo]}
end

# sync ’em
forks.each do |forked|
  puts '---'

  # API spec: https://docs.github.com/en/rest/reference/repos#get-a-repository
  info = github.repos.get(user: options[:username], repo: forked.name)

  upstream_ssh_url = info.source.ssh_url
  original_owner = info.source.owner.login
  name = forked.name
  fork_ssh_url = forked.ssh_url

  upstream_origin_name = 'upstream'
  fork_origin_name = 'fork'
  path = "#{root_dir_path}/#{original_owner}/#{name}"
  already_cloned = Dir.exist?(path)

  # clone any forks not already cloned
  unless already_cloned then
    echo_and_exec "git clone #{fork_ssh_url} #{path}"
  end

  Dir.chdir path do
    fork_default_branch_name = `git remote show #{fork_origin_name} | grep "HEAD branch" | cut -d ":" -f 2`
    fork_default_local_branch_name = "#{fork_origin_name}_#{fork_default_branch_name}"
    upstream_default_branch_name = `git remote show #{upstream_origin_name} | grep "HEAD branch" | cut -d ":" -f 2`
    upstream_default_local_branch_name = "#{upstream_origin_name}_#{upstream_default_branch_name}"

    # if we just cloned the repo locally, set it up with both remotes and local default tracking branches
    unless already_cloned then
      echo_and_exec "git remote add #{upstream_origin_name} #{upstream_ssh_url}"
      echo_and_exec "git remote rename origin #{fork_origin_name}"

      # rename the cloned local default branch to reflect that it's tracking the fork remote's version
      echo_and_exec "git branch -m #{fork_default_branch_name} #{fork_default_local_branch_name}"

      # set up a local branch to track the upstream remote's default branch
      echo_and_exec "git checkout -b #{upstream_default_local_branch_name} #{upstream_origin_name}/#{upstream_default_branch_name}"

      # push the local upstream default tracking branch to the fork's remote, so it also has a copy alongside it's default branch
      echo_and_exec "git push #{fork_origin_name} HEAD:#{upstream_default_local_branch_name}"
    end

    # for repos that were cloned previously, update them by fast-forwarding both default branches and fetch all tags
    if already_cloned then
      echo_and_exec "git checkout #{fork_default_local_branch_name}"
      echo_and_exec "git pull --ff-only #{fork_origin_name}"
      echo_and_exec "git fetch --tags #{fork_origin_name}"

      echo_and_exec "git checkout #{upstream_default_local_branch_name}"
      echo_and_exec "git pull --ff-only #{upstream_origin_name}"
    end
  end
end
